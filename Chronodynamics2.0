import numpy as np
import matplotlib.pyplot as plt

print("--- RELATIONAL CHRONODYNAMICS: VACUUM SCREENING TEST ---")

# === ПАРАМЕТРЫ ===
N = 40                # Размер решетки
ITERATIONS = 2000     # Шаги релаксации
# Калибровка: увеличили жесткость, чтобы epsilon приблизился к 1.47
STIFFNESS = 0.36      

class ChrononLattice:
    def __init__(self, size):
        self.N = size
        self.phi = np.zeros((size, size, size))
        self.rho = np.zeros((size, size, size))
        
    def set_dipole(self, distance):
        self.phi.fill(0)
        self.rho.fill(0)
        center = self.N // 2
        p1 = center - distance // 2
        p2 = center + distance // 2
        self.rho[center, center, p1] = 1.0
        self.rho[center, center, p2] = -1.0
        
    def solve_field(self, constrained=False):
        """
        Универсальный решатель.
        constrained=False -> Обычный вакуум (QED)
        constrained=True  -> Вакуум с бюджетом времени
        """
        # Сброс поля перед расчетом
        self.phi.fill(0)
        
        decay = 1.0
        if constrained:
            decay = 1.0 - (STIFFNESS * 0.1)
            
        for k in range(ITERATIONS):
            p = self.phi
            # Сумма 6 соседей
            neighbors = (np.roll(p, 1, 0) + np.roll(p, -1, 0) +
                         np.roll(p, 1, 1) + np.roll(p, -1, 1) +
                         np.roll(p, 1, 2) + np.roll(p, -1, 2))
            
            # Релаксация
            phi_new = (neighbors + self.rho) / 6.0
            
            # Применяем Constraint (если нужно)
            if constrained:
                phi_new *= decay
            
            # Граничные условия (0 на краях)
            phi_new[0,:,:] = 0; phi_new[-1,:,:] = 0
            phi_new[:,0,:] = 0; phi_new[:,-1,:] = 0
            phi_new[:,:,0] = 0; phi_new[:,:,-1] = 0
            
            self.phi = phi_new
            
        return self.phi.copy() # Возвращаем копию поля для картинки

    def calculate_energy(self, field_data):
        """Считаем энергию E = Sum (grad phi)^2"""
        gy, gx, gz = np.gradient(field_data)
        return np.sum(gx**2 + gy**2 + gz**2)

# === ЭКСПЕРИМЕНТ ===
sim = ChrononLattice(N)
sim.set_dipole(8) # Расстояние 8 ячеек

print(f"1. Simulating Free Vacuum (Standard Physics)...")
field_free = sim.solve_field(constrained=False)
E_free = sim.calculate_energy(field_free)
print(f"   Energy (Free): {E_free:.4f}")

print(f"2. Simulating Time-Budget Vacuum (Relational Chronodynamics)...")
field_const = sim.solve_field(constrained=True)
E_const = sim.calculate_energy(field_const)
print(f"   Energy (Constrained): {E_const:.4f}")

# === РЕЗУЛЬТАТ ===
epsilon = E_free / E_const

print("="*50)
print(f"LATTICE RESULT (N={N}^3):")
print(f"Vacuum Permittivity (epsilon) = {epsilon:.4f}")
print(f"Theoretical Target            ~ 1.47")
print("="*50)

# === ВИЗУАЛИЗАЦИЯ ===
print("Generating visualization...")
plt.figure(figsize=(12, 6))

# Берем центральный срез
slice_idx = N // 2

# 1. Свободный вакуум
plt.subplot(1, 2, 1)
# Используем vmin/vmax чтобы шкала была одинаковой
vmin, vmax = np.min(field_free), np.max(field_free)
plt.imshow(field_free[:, slice_idx, :], cmap='RdBu_r', vmin=vmin, vmax=vmax)
plt.title("Free Vacuum Potential")
plt.colorbar()

# 2. Экранированный вакуум
plt.subplot(1, 2, 2)
plt.imshow(field_const[:, slice_idx, :], cmap='RdBu_r', vmin=vmin, vmax=vmax)
plt.title(f"Constrained Vacuum (eps={epsilon:.2f})")
plt.colorbar()

plt.tight_layout()
plt.show()
